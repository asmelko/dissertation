
\chapter{Astute Approach to Handling Memory Layouts of Regular Data Structures}
% %
% \titlerunning{Handling Memory Layouts of Regular Data Structures}
% % If the paper title is too long for the running head, you can set
% % an abbreviated paper title here
% %
% \author{
%     % Anonymous\inst{1}
%     Adam Šmelko\inst{1} \and %
%     Martin Kruliš\inst{1} \and %
%     Miroslav Kratochvíl\inst{2} \and %
%     Jiří Klepl\inst{1} \and % https://orcid.org/0000-0002-2231-4073
%     Jiří Mayer\inst{1} \and % https://orcid.org/0000-0001-6503-3442
%     Petr Šimůnek\inst{1} %https://orcid.org/0000-0003-0089-7201
% }
% \authorrunning{
%     % Anonymous et al.
%     Šmelko et al.
% }
% % First names are abbreviated in the running head.
% % If there are more than two authors, 'et al.' is used.
% %
% \institute{
%     % Anonymized due to double-blind review process
%     Department of Distributed and Dependable Systems, Charles University, Prague, Czech Republic\\
%     \email{\{smelko,krulis\}@d3s.mff.cuni.cz}
%     \and
%     Luxembourg Centre for Systems Biomedicine, University of Luxembourg, Esch-sur-Alzette\\
%     \email{miroslav.kratochvil@uni.lu}
% }
% %
% \maketitle              % typeset the header of the contribution
% %
% \begin{abstract}
% Programmers of high-performance applications face many challenging aspects of contemporary hardware architectures. One of the critical aspects is the efficiency of memory operations which is affected not only by the hardware parameters such as memory throughput or cache latency but also by the data-access patterns, which may influence the utilization of the hardware, such as re-usability of the cached data or coalesced data transactions. Therefore, a performance of an algorithm can be highly impacted by the layout of its data structures or the order of data processing which may translate into a more or less optimal sequence of memory operations. These effects are even more pronounced on highly-parallel platforms, such as GPUs, which often employ specific execution models (lock-step) or memory models (shared memory).

% In this work, we propose a modern, astute approach for managing and implementing memory layouts with first-class structures that is very efficient and straightforward. This approach was implemented in \Noarr{}, a GPU-ready portable C++ library that utilizes generic programming, functional design, and compile-time computations to allow the programmer to specify and compose data structure layouts declaratively while minimizing the indexing and coding overhead. We describe the main principles on code examples and present a performance evaluation that verifies our claims regarding its efficiency.
% \keywords{memory layout \and data structure \and cache \and parallel \and performance \and reusable}
% \end{abstract}

\input{noarr/introduction.tex}
%\input{motivation.tex}
\input{noarr/matrix-layouts.tex}
% \input{transformations.tex}
\input{noarr/index-perf.tex}
\input{noarr/technical.tex}
\input{noarr/relwork.tex}

% -----------------------------------------------------------------------------
\section{Conclusion}\label{sec:conclusion}
% -----------------------------------------------------------------------------

We have presented a new high-performance approach for managing the complexity of offset computation in array-like data structures in modern C++. We introduced first-class layout structures that can be used to describe complex array layouts and run the required offset computations. The implementation is based on C++ template metaprogramming, exposing a rich interface for manipulating the structures with index mnemonics while enabling many compiler optimizations by properly separating static compile-time parameters and known constants from dynamic data.

The technique promotes complete decoupling of array indexing from memory allocation, which makes it applicable for many scenarios, including direct processing of memory-mapped files or re-using the same data structure layout in various memory spaces (e.g., offloading computations to GPUs). We showed that the layout structures, combined with the C++ templating system, make it easier to create layout-agnostic algorithms and functions, leading to a simpler selection of optimal layouts for a given hardware platform and problem configuration. Additionally, the utilization of layout structures makes it easier to create semi-automated layout transform routines, which can improve the performance of many algorithms.

We have implemented the proposed ideas in \Noarr{}, a prototype library demonstrating the viability of the approach. We demonstrated the benefits in several examples and experiments; most importantly, we showcased the ability to write shorter program source code that promotes easier experimentation and compilation into faster solutions. The library is publicly available as an open-source portable to all mainstream compilers, including CUDA \texttt{nvcc}, and may be readily used in designing new libraries that consider performance a priority. We expect that the approach will simplify the research focusing on optimizations and automatic tuning of the performance of complex parallel algorithms.

% \subsection*{Acknowledgements}

% This work was supported by Charles University institutional funding SVV 260451.

% \appendix

\input{noarr/methodology.tex}

