\section{Related Work}\label{sec:relwork}

A significant group of works that touch the problem of memory layouts are parallel programming languages such as X10~\cite{charles2005x10}, Chapel~\cite{chamberlain2007parallel} or Legion~\cite{bauer2012legion}. Apart from providing syntax for simple parallel code expression, these languages allow for data decomposition into regions that can be mapped within the same memory space or more complex non-uniform memory spaces. Hence, the memory layout expression addressed by these works is only researched to the point of high-level data distribution among processing elements.

Application-specific library generators, or \emph{active libraries}, also utilize memory layouts. The most known representatives are ATLAS~\cite{whaley1998automatically}, SPIRAL~\cite{puschel2004spiral} and FFTW~\cite{frigo1998fftw} specializing in linear algebra, signal processing, and Fast Fourier Transform, respectively. They are trying to mitigate portability issues of manually optimized programs by selecting the best interprocedural optimizations for the hosting system using autotuning. Usually, these optimization strategies include some form of memory layout selection. It is important to note that active libraries target different stages in programming than \Noarr{}; rather than performing the layout selection from the hardcoded set of layouts, \Noarr{} provides means to \emph{implement} such layout selections in a more extensible and object-oriented way.

The most related works we found are Kokkos \cite{9485033}, and GridTools \cite{AFANASYEV2021100707}. These libraries allow the coupling of arbitrary data structures with memory layouts which can be either selected from a set of predefined layouts or programmatically customized.

GridTools specialize in block-structured grid applications such as combustion, seismic, and weather simulations, working with generalized stencil-like patterns. The library defines a storage infrastructure component that controls the layout, alignment, and padding of stored data fields. A layout is specified in code at compile time by selecting one of the predefined target backends, each well suited for a specific use case, such as vector instructions or GPU kernels. The library can be extended with new programmer-specified backends, but the layout can be altered only by permuting dimension order in a regular $n$-dimensional array. 

An interesting approach is taken in the Kokkos library, which specifies the \texttt{View} class that couples the definition of data memory space, allocation, and layout altogether using C++ policy classes, yielding an object of similar functionality as our \texttt{bag}. The memory resource and allocation mechanism are abstracted and defined by the template argument. Kokkos provides multiple memory spaces such as \texttt{HostSpace}, \texttt{CudaSpace}, \texttt{CudaHostPinnedSpace}, thus representing CPU and GPU physical memory and their combinations.

In Kokkos, the memory layout is either implicitly deduced from the memory space or explicitly specified as another template parameter. The library implements row and column-major layouts together with the layout with strides with custom sizes. Kokkos allows user-defined memory layouts by defining a new layout policy and implementing a function that defines a bijective mapping between index space and memory addresses. However, this mapping must be defined on a regular $n$-dimensional array, using a minimal API that fits the \texttt{View} class.

Language-wise, our approach is similar to (and inspired by) known concepts from functional programming. Materialized, first-class composable references to sub-structures uncoupled from data have been extensively studied as optics~\cite{foster2007combinators}. In particular, the internal structures that implement the selection of array slices at certain indexes are similar to the concept of indexed lenses --- kind of references that transparently provide information about the current index in a complicated structure, as summarized by Clarke et~al.~\cite{clarke2020profunctor} In the future, it might be interesting to examine whether more advanced optics may be modeled in C++ for array accesses, e.g., expressing repeated data accesses similarly to lens-based traversals or reconstructing the user-facing indexes from known offsets using isomorphisms.


% TiDa and GridTools specialize in block-structured grid applications such as combustion, seismic, and weather simulations, working with generalized stencil-like patterns. TiDa allows the programmer to express data locality and layout at the array construction by declaring how the data is divided into regions to be accessed by different processing elements (such as NUMA nodes), which are further divided into tiles for finer layout granularity.


% Extensive research has been performed in choosing optimal layouts concerning a provided algorithm. For example, Sharma et al.~\cite{10.1145/2747875} investigated a transformation technique called array interleaving, which combines the storage of data elements from multiple arrays to achieve better data locality. Sung et al.~\cite{sung2010data} presented compiler optimization that enables data layout transformation for structured grid codes with dynamically allocated arrays (e.g., stencil functions). These involve source-to-source program transformation to generate functions that can transform the data into a `better' layout with more locality. Both authors observed performance increases, reductions in memory transfers, and improvements in memory access patterns.


% parallel libraries with much wider functionalities than just layout transformations:
% \begin{enumerate}
%     \item \emph{kokkos} \cite{9485033,CARTEREDWARDS20143202}
%     \subitem provides class View that defines memory space, allocation, layout alltogether via policy classes.
%     \subitem Memory space template represents allocation mechanism. Kokkos imlpements multiple types: HostSpace, CudaSpace, CudaHostPinnedSpace indexing is implemented by DeviceType, a policy class.
%     \subitem Layout is statically inlined, primarily LayoutLeft, LaoutRight, LayoutStride.
%     \subitem on top of that, there is third policy class. Memory Traits. Provides additional info about memory behavior --- whether to utilize texture memory in CUDA, atomic access, ...
%     \subitem View in its constructor defines sizes of dimensions, but can be provided staticaly via template argument as well. In its constructor, it allocates data according to memory space policy. It can be coppied to create a view of the data. effectively creating shared-ptr semantics over the data.
%     \item \emph{TiDa} \cite{tida}. library supports programs operating on block-structured grid applications such as combustion, seismic, weather simulations and image processing. Divides data into regions to improve data locality on NUMA nodes. regions are divided into tiles improve cache reuse.
%     \item \emph{GridTools} \cite{AFANASYEV2021100707}. Only custom possibility is to permute dimensions in ndarray. Other than that, it supports general layouts for some common cases (vectorization, gpu).
% \end{enumerate}

% works targeted on finding optimal memory layout and layout transformation:
% \begin{enumerate}
%     \item \cite{10.1145/2747875} efficient layout transformation via array interleaving to improve memory accesses for SIMD FUs, SMPs, vector registers. Achieves decrease in memory energy consumption 6-36 percent.
%     \item \cite{sung2010data} presents compiler optimization that enables data layout transformation for structured grid
%     codes (stencil, fluid dynamics, heat dicipation) in CUDA. It involves source to source compilation that generates transformative functions that result in layout with better data locality. The code must be further compiled by NVCC (or other suitable) compiler.   
% \end{enumerate}

% purely functional haskel libarary for writing multi-dimensional arrays.
